	// let unitReferences = $derived.by(() => {
	// 	let references: SvelteMap<string, MulUnit> = new SvelteMap();
	// 	for (const unit of playList?.units ?? []) {
	// 		loadMULUnit(unit.mulId).then((result) => {
	// 			references.set(unit.id, result);
	// 		});
	// 	}
	// 	return references;
	// });

	// let logDrawerOpen = $state(false);
	// const currentRoundLog = new PersistedState<LogRound>("playCurrentRound", { round: 1, logs: [] });
	// let fullLogs: LogRound[] = $state([]);

	// function resetList() {
	// 	if (playList) {
	// 		const reset = confirm("Are you sure you wish to reset all units to default? This cannot be undone.");
	// 		if (reset) {
	// 			for (const unit of playList?.units) {
	// 				unit.current = { damage: 0, heat: 0, crits: [], disabledAbilities: [] };
	// 				unit.pending = { damage: 0, heat: 0, crits: [] };
	// 			}
	// 			fullLogs = [];
	// 			currentRoundLog.current = { round: 1, logs: [] };
	// 		}
	// 	}
	// }

	// function endRound() {
	// 	if (playList) {
	// 		const end = confirm("End round and apply all pending damage, heat, and critical effects?");
	// 		if (end) {
	// 			for (const unit of playList?.units) {
	// 				unit.current.damage = unit.current.damage + unit.pending.damage;
	// 				unit.current.heat = unit.pending.heat;
	// 				unit.current.crits = unit.current.crits.concat(unit.pending.crits);

	// 				unit.pending.damage = 0;
	// 				unit.pending.crits = [];
	// 			}
	// 			for (const log of currentRoundLog.current.logs) {
	// 				log.applied = true;
	// 			}
	// 			fullLogs.push({ round: currentRoundLog.current.round, logs: currentRoundLog.current.logs });
	// 			currentRoundLog.current = { round: currentRoundLog.current.round + 1, logs: [] };
	// 		}
	// 	}
	// }

	// function endMatch() {
	// 	if (confirm("End match and remove it from active matches?")) {
	// 		if (playList?.id) db.localMatches.delete(playList?.id);
	// 		window.location.href = "/play";
	// 	}
	// }

	// function openLog() {
	// 	logDrawerOpen = !logDrawerOpen;
	// }