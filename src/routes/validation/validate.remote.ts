import { form, query } from "$app/server";
import { getGeneralId } from "$lib/remote/era-faction.remote";
import { getMULDataFromId, getMULDataFromName, isAvailable, isUnique } from "$lib/remote/unit.remote";
import { getDocument } from "pdfjs-dist";
import { getUnitDataFromPDF } from "./parse";
import { prisma } from "$lib/server/prisma";
import { getNewSkillCost } from "$lib/utilities/genericBattletechUtilities";
import type { ValidationUnitData } from "./types";
import { nanoid } from "nanoid";
import * as v from "valibot";

export const getUnitData = form(v.object({ listFile: v.file(), selectedEra: v.string(), selectedFaction: v.string() }), async ({ listFile, selectedEra, selectedFaction }) => {
	const era = Number(selectedEra);
	const faction = Number(selectedFaction);
	let unitData: ValidationUnitData[] = [];

	const buffer = await listFile.arrayBuffer();
	const pdf = await getDocument(buffer).promise;
	const metadata = (await pdf.getMetadata()).info;
	const page = await pdf.getPage(1);
	const content = await page.getTextContent();

	const parsedData = getUnitDataFromPDF(content, metadata);

	if (parsedData.status == "failed")
		return { status: "failed", message: "Invalid PDF Format. Either it wasn't generated by the MUL or this site, or my reader is broken somehow." };
	if (parsedData.status == "ongoing")
		return { status: "failed", message: "PDF format will be supported soon, but is currently in progress. Please upload a pdf generated from the MUL" };

	for (const parsedUnit of parsedData.data ?? []) {
		const unit = await getMULDataFromName(parsedUnit.name);
		if (unit) {
			let unique: boolean | undefined = await isUnique({ mulId: unit.mulId, era });
			const general = (await getGeneralId({ era, faction }))?.general;
			let available: boolean | undefined = (await isAvailable({ mulId: unit.mulId, eras: [era], factions: [faction, general ?? 0] })) || unit.mulId < 0;

			unitData.push({
				id: crypto.randomUUID(),
				name: parsedUnit.name,
				skill: parsedUnit.skill,
				pv: parsedUnit.pv,
				mulData: unit,
				link: unit ? `http://masterunitlist.info/Unit/Details/${unit.mulId}` : undefined,
				unique: unique,
				available: available
			});
		} else {
			unitData.push({
				id: nanoid(),
				name: parsedUnit.name,
				skill: parsedUnit.skill,
				pv: parsedUnit.pv
			});
		}
	}
	await nothing().refresh();
	return { status: "success", data: unitData };
});

export const getPossibleUnitList = form(v.object({ searchTerm: v.string() }), async ({ searchTerm }) => {
	const results = await prisma.unit.findMany({ where: { name: { contains: searchTerm } }, select: { mulId: true, name: true } });

	await nothing().refresh();
	return results;
});

export const fixUnitData = form(
	v.object({ selectedUnitId: v.string(), unitSkill: v.string(), eraId: v.string(), factionId: v.string() }),
	async ({ selectedUnitId, unitSkill, eraId, factionId }) => {
		const mulId = Number(selectedUnitId);
		const mulData = await getMULDataFromId(mulId);

		const skill = Number(unitSkill);
		const era = Number(eraId);
		const faction = Number(factionId);

		await nothing().refresh();
		if (mulData == undefined) {
			return { status: "failed", message: "Invalid Unit Id" };
		} else {
			const unique = await isUnique({ mulId: mulId, era });
			const general = (await getGeneralId({ era, faction }))?.general;
			const available = await isAvailable({ mulId: mulId, eras: [era], factions: [faction, general ?? 0] });

			let unitData: ValidationUnitData = {
				id: crypto.randomUUID(),
				name: mulData.data!.name,
				skill,
				pv: getNewSkillCost(skill, mulData.data!.pv),
				mulData: mulData.data,
				link: `http://masterunitlist.info/Unit/Details/${mulData.data!.mulId}`,
				unique,
				available
			};
			return { status: "success", data: unitData };
		}
	}
);

export const nothing = query(async () => {});
